import os
import pathlib
import warnings

import yaml
from md_utils import dict_to_table

import minari
from minari.utils import get_dataset_spec_dict


DATASET_FOLDER = pathlib.Path(__file__).parent.parent.joinpath("datasets")


def _rst_escape(text: str) -> str:
    return text.replace("*", r"\*").replace("_", r"\_").replace("`", r"\`")


def _parse_dataset_path(dataset_path: str) -> tuple:
    """Parse a dataset path that may include a remote prefix.

    Args:
        dataset_path: Dataset ID, optionally with remote prefix (e.g., "hf://user/dataset-id")

    Returns:
        Tuple of (remote_path, dataset_id) where remote_path is None for default remote
    """
    if "://" in dataset_path:
        remote_type, rest = dataset_path.split("://", maxsplit=1)
        remote_name, dataset_id = rest.split("/", maxsplit=1)
        remote_path = f"{remote_type}://{remote_name}"
        return remote_path, dataset_id
    return None, dataset_path


def _generate_community_dataset_page(dataset_entry):
    """Generate a dataset page for a community dataset."""
    dataset_path = dataset_entry.get("dataset_id", "")
    display_name = dataset_entry.get("display_name", dataset_path)

    if not dataset_path:
        warnings.warn(f"Skipping dataset entry without dataset_id: {dataset_entry}")
        return

    try:
        # Parse the dataset path to extract remote_path if present
        remote_path, dataset_id = _parse_dataset_path(dataset_path)

        # Get metadata from the appropriate remote
        remote_datasets = minari.list_remote_datasets(
            remote_path=remote_path, latest_version=True
        )
        if dataset_id not in remote_datasets:
            warnings.warn(f"Dataset {dataset_id} not found in remote datasets")
            return

        metadata = remote_datasets[dataset_id]

        # Extract description, author, and tags from metadata
        description = metadata.get("description", "")

        # Generate page content with custom title
        content = "---\nautogenerated:\n"
        content += f"title: {display_name}\n"
        content += "---\n\n"
        content += f"# {display_name}\n\n"

        if description:
            content += "## Description\n\n"
            content += description + "\n\n"

        content += "## Dataset Specs\n\n"
        content += dict_to_table(get_dataset_spec_dict(metadata))
        content += "\n\n"

        # Add environment specs if available
        env_spec = metadata.get("env_spec")
        if env_spec is not None:
            content += "## Environment Specs\n\n"
            content += "This environment can be recovered from the Minari dataset as follows:\n\n"
            content += "```python\n"
            content += "import minari\n"
            load_path = dataset_path if remote_path else dataset_id
            content += f"dataset = minari.load_dataset('{load_path}', download=True)\n"
            content += "env = dataset.recover_environment()\n"
            content += "```\n\n"

        # Write dataset page in the same location as regular datasets
        # Save as dataset_id + ".md" (same pattern as gen_dataset_md.py)
        dataset_md_path = DATASET_FOLDER.joinpath(dataset_id + ".md")
        os.makedirs(os.path.dirname(dataset_md_path), exist_ok=True)

        with open(dataset_md_path, "w", encoding="utf-8") as f:
            f.write(content)

        print(f"Generated community dataset page for {dataset_id}")

    except Exception as e:
        warnings.warn(f"Failed to generate page for {dataset_path}: {e}")


def _get_dataset_metadata(dataset_path: str) -> dict:
    """Get metadata for a dataset, handling custom remotes.

    Args:
        dataset_path: Dataset ID, optionally with remote prefix

    Returns:
        Metadata dict or empty dict if not found
    """
    remote_path, dataset_id = _parse_dataset_path(dataset_path)
    try:
        remote_datasets = minari.list_remote_datasets(
            remote_path=remote_path, latest_version=True
        )
        return remote_datasets.get(dataset_id, {})
    except Exception:
        return {}


def generate_community_page(
    yaml_path=DATASET_FOLDER.joinpath("community", "community.yaml"),
    out_rst=DATASET_FOLDER.joinpath("community", "index.rst"),
):
    if not os.path.exists(yaml_path):
        raise FileNotFoundError(f"YAML file not found: {yaml_path}")

    with open(yaml_path) as f:
        community_data = yaml.safe_load(f) or []

    # Generate individual dataset pages first
    for dataset_entry in community_data:
        _generate_community_dataset_page(dataset_entry)

    # Generate the index page
    content = "Community Datasets\n"
    content += "==================\n\n"
    content += "Below is a list of datasets contributed by the community.\n\n"

    content += ".. raw:: html\n\n"
    content += '    <div class="sphx-glr-thumbnails">\n\n'

    for dataset_entry in community_data:
        dataset_path = dataset_entry.get("dataset_id", "")
        display_name = _rst_escape(dataset_entry.get("display_name", dataset_path))

        # Parse the path to get the actual dataset_id for URL
        _, dataset_id = _parse_dataset_path(dataset_path)

        # Get description from metadata (handles custom remotes)
        metadata = _get_dataset_metadata(dataset_path)
        description = _rst_escape(metadata.get("description", ""))
        local_url = f"/datasets/{dataset_id}/"

        # Thumb card - matching tutorial style
        content += ".. raw:: html\n\n"
        tooltip = description if description else display_name
        content += f'    <div class="sphx-glr-thumbcontainer" tooltip="{tooltip}">\n\n'

        content += ".. only:: html\n\n"
        # Default to minari-text.png with width constraint to match tutorial cards
        # Wrap image in link using target directive
        img_src = "/_static/img/minari-text.png"
        content += f"  .. image:: {img_src}\n"
        content += f"    :alt: {display_name}\n"
        content += "    :width: 400px\n"
        content += f"    :target: {local_url}\n\n"

        content += ".. raw:: html\n\n"
        content += f'      <div class="sphx-glr-thumbnail-title">{display_name}</div>\n'
        content += "    </div>\n\n"

    # Add "Add your own dataset" card
    content += ".. raw:: html\n\n"
    content += '    <div class="sphx-glr-thumbcontainer" tooltip="Add your own dataset to this page">\n\n'

    content += ".. only:: html\n\n"
    # Link to README with instructions
    readme_url = "https://github.com/Farama-Foundation/Minari/blob/main/docs/datasets/community/README.md"
    content += "  .. image:: /_static/img/minari-text.png\n"
    content += "    :alt: Add Your Dataset\n"
    content += "    :width: 400px\n"
    content += f"    :target: {readme_url}\n\n"

    content += ".. raw:: html\n\n"
    content += '      <div class="sphx-glr-thumbnail-title">Add Your Dataset</div>\n'
    content += "    </div>\n\n"

    content += ".. raw:: html\n\n"
    content += "    </div>\n\n"

    os.makedirs(os.path.dirname(out_rst), exist_ok=True)
    with open(out_rst, "w", encoding="utf-8") as f:
        f.write(content)


def main():
    generate_community_page()


if __name__ == "__main__":
    main()
